"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformConstraintTypeToGraphQL = void 0;

var defaultGraphQLTypes = _interopRequireWildcard(require("../loaders/defaultGraphQLTypes"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const transformConstraintTypeToGraphQL = (parseType, targetClass, parseClassTypes) => {
  switch (parseType) {
    case 'String':
      return defaultGraphQLTypes.STRING_WHERE_INPUT;

    case 'Number':
      return defaultGraphQLTypes.NUMBER_WHERE_INPUT;

    case 'Boolean':
      return defaultGraphQLTypes.BOOLEAN_WHERE_INPUT;

    case 'Array':
      return defaultGraphQLTypes.ARRAY_WHERE_INPUT;

    case 'Object':
      return defaultGraphQLTypes.OBJECT_WHERE_INPUT;

    case 'Date':
      return defaultGraphQLTypes.DATE_WHERE_INPUT;

    case 'Pointer':
      if (parseClassTypes[targetClass] && parseClassTypes[targetClass].classGraphQLConstraintType) {
        return parseClassTypes[targetClass].classGraphQLConstraintType;
      } else {
        return defaultGraphQLTypes.OBJECT;
      }

    case 'File':
      return defaultGraphQLTypes.FILE_WHERE_INPUT;

    case 'GeoPoint':
      return defaultGraphQLTypes.GEO_POINT_WHERE_INPUT;

    case 'Polygon':
      return defaultGraphQLTypes.POLYGON_WHERE_INPUT;

    case 'Bytes':
      return defaultGraphQLTypes.BYTES_WHERE_INPUT;

    case 'ACL':
      return defaultGraphQLTypes.OBJECT_WHERE_INPUT;

    case 'Relation':
    default:
      return undefined;
  }
};

exports.transformConstraintTypeToGraphQL = transformConstraintTypeToGraphQL;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9HcmFwaFFML3RyYW5zZm9ybWVycy9jb25zdHJhaW50VHlwZS5qcyJdLCJuYW1lcyI6WyJ0cmFuc2Zvcm1Db25zdHJhaW50VHlwZVRvR3JhcGhRTCIsInBhcnNlVHlwZSIsInRhcmdldENsYXNzIiwicGFyc2VDbGFzc1R5cGVzIiwiZGVmYXVsdEdyYXBoUUxUeXBlcyIsIlNUUklOR19XSEVSRV9JTlBVVCIsIk5VTUJFUl9XSEVSRV9JTlBVVCIsIkJPT0xFQU5fV0hFUkVfSU5QVVQiLCJBUlJBWV9XSEVSRV9JTlBVVCIsIk9CSkVDVF9XSEVSRV9JTlBVVCIsIkRBVEVfV0hFUkVfSU5QVVQiLCJjbGFzc0dyYXBoUUxDb25zdHJhaW50VHlwZSIsIk9CSkVDVCIsIkZJTEVfV0hFUkVfSU5QVVQiLCJHRU9fUE9JTlRfV0hFUkVfSU5QVVQiLCJQT0xZR09OX1dIRVJFX0lOUFVUIiwiQllURVNfV0hFUkVfSU5QVVQiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUVBLE1BQU1BLGdDQUFnQyxHQUFHLENBQ3ZDQyxTQUR1QyxFQUV2Q0MsV0FGdUMsRUFHdkNDLGVBSHVDLEtBSXBDO0FBQ0gsVUFBUUYsU0FBUjtBQUNFLFNBQUssUUFBTDtBQUNFLGFBQU9HLG1CQUFtQixDQUFDQyxrQkFBM0I7O0FBQ0YsU0FBSyxRQUFMO0FBQ0UsYUFBT0QsbUJBQW1CLENBQUNFLGtCQUEzQjs7QUFDRixTQUFLLFNBQUw7QUFDRSxhQUFPRixtQkFBbUIsQ0FBQ0csbUJBQTNCOztBQUNGLFNBQUssT0FBTDtBQUNFLGFBQU9ILG1CQUFtQixDQUFDSSxpQkFBM0I7O0FBQ0YsU0FBSyxRQUFMO0FBQ0UsYUFBT0osbUJBQW1CLENBQUNLLGtCQUEzQjs7QUFDRixTQUFLLE1BQUw7QUFDRSxhQUFPTCxtQkFBbUIsQ0FBQ00sZ0JBQTNCOztBQUNGLFNBQUssU0FBTDtBQUNFLFVBQ0VQLGVBQWUsQ0FBQ0QsV0FBRCxDQUFmLElBQ0FDLGVBQWUsQ0FBQ0QsV0FBRCxDQUFmLENBQTZCUywwQkFGL0IsRUFHRTtBQUNBLGVBQU9SLGVBQWUsQ0FBQ0QsV0FBRCxDQUFmLENBQTZCUywwQkFBcEM7QUFDRCxPQUxELE1BS087QUFDTCxlQUFPUCxtQkFBbUIsQ0FBQ1EsTUFBM0I7QUFDRDs7QUFDSCxTQUFLLE1BQUw7QUFDRSxhQUFPUixtQkFBbUIsQ0FBQ1MsZ0JBQTNCOztBQUNGLFNBQUssVUFBTDtBQUNFLGFBQU9ULG1CQUFtQixDQUFDVSxxQkFBM0I7O0FBQ0YsU0FBSyxTQUFMO0FBQ0UsYUFBT1YsbUJBQW1CLENBQUNXLG1CQUEzQjs7QUFDRixTQUFLLE9BQUw7QUFDRSxhQUFPWCxtQkFBbUIsQ0FBQ1ksaUJBQTNCOztBQUNGLFNBQUssS0FBTDtBQUNFLGFBQU9aLG1CQUFtQixDQUFDSyxrQkFBM0I7O0FBQ0YsU0FBSyxVQUFMO0FBQ0E7QUFDRSxhQUFPUSxTQUFQO0FBbENKO0FBb0NELENBekNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZGVmYXVsdEdyYXBoUUxUeXBlcyBmcm9tICcuLi9sb2FkZXJzL2RlZmF1bHRHcmFwaFFMVHlwZXMnO1xuXG5jb25zdCB0cmFuc2Zvcm1Db25zdHJhaW50VHlwZVRvR3JhcGhRTCA9IChcbiAgcGFyc2VUeXBlLFxuICB0YXJnZXRDbGFzcyxcbiAgcGFyc2VDbGFzc1R5cGVzXG4pID0+IHtcbiAgc3dpdGNoIChwYXJzZVR5cGUpIHtcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgcmV0dXJuIGRlZmF1bHRHcmFwaFFMVHlwZXMuU1RSSU5HX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ051bWJlcic6XG4gICAgICByZXR1cm4gZGVmYXVsdEdyYXBoUUxUeXBlcy5OVU1CRVJfV0hFUkVfSU5QVVQ7XG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgICByZXR1cm4gZGVmYXVsdEdyYXBoUUxUeXBlcy5CT09MRUFOX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ0FycmF5JzpcbiAgICAgIHJldHVybiBkZWZhdWx0R3JhcGhRTFR5cGVzLkFSUkFZX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICByZXR1cm4gZGVmYXVsdEdyYXBoUUxUeXBlcy5PQkpFQ1RfV0hFUkVfSU5QVVQ7XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICByZXR1cm4gZGVmYXVsdEdyYXBoUUxUeXBlcy5EQVRFX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ1BvaW50ZXInOlxuICAgICAgaWYgKFxuICAgICAgICBwYXJzZUNsYXNzVHlwZXNbdGFyZ2V0Q2xhc3NdICYmXG4gICAgICAgIHBhcnNlQ2xhc3NUeXBlc1t0YXJnZXRDbGFzc10uY2xhc3NHcmFwaFFMQ29uc3RyYWludFR5cGVcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gcGFyc2VDbGFzc1R5cGVzW3RhcmdldENsYXNzXS5jbGFzc0dyYXBoUUxDb25zdHJhaW50VHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0R3JhcGhRTFR5cGVzLk9CSkVDVDtcbiAgICAgIH1cbiAgICBjYXNlICdGaWxlJzpcbiAgICAgIHJldHVybiBkZWZhdWx0R3JhcGhRTFR5cGVzLkZJTEVfV0hFUkVfSU5QVVQ7XG4gICAgY2FzZSAnR2VvUG9pbnQnOlxuICAgICAgcmV0dXJuIGRlZmF1bHRHcmFwaFFMVHlwZXMuR0VPX1BPSU5UX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgcmV0dXJuIGRlZmF1bHRHcmFwaFFMVHlwZXMuUE9MWUdPTl9XSEVSRV9JTlBVVDtcbiAgICBjYXNlICdCeXRlcyc6XG4gICAgICByZXR1cm4gZGVmYXVsdEdyYXBoUUxUeXBlcy5CWVRFU19XSEVSRV9JTlBVVDtcbiAgICBjYXNlICdBQ0wnOlxuICAgICAgcmV0dXJuIGRlZmF1bHRHcmFwaFFMVHlwZXMuT0JKRUNUX1dIRVJFX0lOUFVUO1xuICAgIGNhc2UgJ1JlbGF0aW9uJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuZXhwb3J0IHsgdHJhbnNmb3JtQ29uc3RyYWludFR5cGVUb0dyYXBoUUwgfTtcbiJdfQ==